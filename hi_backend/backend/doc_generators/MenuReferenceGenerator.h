/*  ===========================================================================
*
*   This file is part of HISE.
*   Copyright 2016 Christoph Hart
*
*   HISE is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   HISE is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with HISE.  If not, see <http://www.gnu.org/licenses/>.
*
*   Commercial licenses for using HISE in an closed source project are
*   available on request. Please visit the project's website to get more
*   information about commercial licensing:
*
*   http://www.hise.audio/
*
*   HISE is based on the JUCE library,
*   which must be separately licensed for closed source applications:
*
*   http://www.juce.com
*
*   ===========================================================================
*/


#pragma once

namespace hise {
using namespace juce;

namespace MenuReferenceDocGenerator
{
	constexpr static char descriptionWildcard[] = "/working-with-hise";

	struct CommonData
	{
		CommonData(const File& root)
		{
			rootURL = { root, descriptionWildcard };
		}

		virtual ~CommonData()
		{
			MessageManagerLock mmLock;

			data->r = nullptr;
		};

		struct Data
		{
			~Data()
			{
				r = nullptr;
				factories.clear();
				bp = nullptr;
			}
			
			void createRootWindow(BackendProcessor* newBp)
			{
				if (r != nullptr)
					return;

				root = bp->getDatabaseRootDirectory();
				bp = newBp;

				MessageManagerLock mmLock;

				r = bp->getDocWindow();

			}

			void createMenuCommandInfos()
			{
				jassert(bp != nullptr);
				createRootWindow(bp);

				if (commandInfos.isEmpty())
				{
					Array<int> commands;

					r->getAllCommands(commands);

					for (auto c : commands)
					{
						ApplicationCommandInfo result(c);
						r->getCommandInfo(c, result);
						commandInfos.add(std::move(result));
					}
				}
			}
			
			Array<ApplicationCommandInfo> commandInfos;

			OwnedArray<PathFactory> factories;

			File root;
			BackendProcessor* bp = nullptr;
			Component::SafePointer<BackendRootWindow> r;
		};

		template <class T> void registerFactories()
		{
			data->factories.add(new T());
		}

		MarkdownLink rootURL;
		SharedResourcePointer<Data> data;
	};

	struct ItemGenerator : public MarkdownDataBase::ItemGeneratorBase,
						   public CommonData
	{
		ItemGenerator(File root, MarkdownDatabaseHolder& holder) :
			ItemGeneratorBase(root),
			CommonData(root)
		{
			data->bp = dynamic_cast<BackendProcessor*>(&holder);
			colour = Colour(0xFF73CF8F);
		};

		void createMenuReference(MarkdownDataBase::Item& parent);

		void createMenu(MarkdownDataBase::Item& parent, const String& menuName);

		void createAndAddWorkspacesItem(MarkdownDataBase::Item& parent);

		void createAndAddWorkspace(MarkdownDataBase::Item& parent, const String& id);

		void createSettingsItem(MarkdownDataBase::Item& parent);

		void createSettingSubMenu(MarkdownDataBase::Item& parent, const String& name);

		void addItemForSettingList(const Array<Identifier>& idList, const String& subName, MarkdownDataBase::Item& parent);

		MarkdownDataBase::Item createRootItem(MarkdownDataBase& parent) override;
	};
	
	class Resolver : public MarkdownParser::LinkResolver,
					public CommonData
	{
	public:

		Resolver(File root):
			CommonData(root),
			rootDirectory(root)
		{};

		Identifier getId() const override { return "PathDescriptionResolver"; }
		MarkdownParser::ResolveType getPriority() const override { return MarkdownParser::ResolveType::Autogenerated; }
		LinkResolver* clone(MarkdownParser* ) const override { return new Resolver(*this); }
		String getContent(const MarkdownLink& url) override;

		String generateIconTable(const String& url, const String& fileContent) const;

		File rootDirectory;
	};

	class MenuGenerator : public MarkdownParser::LinkResolver,
						  public CommonData
	{
	public:

		MenuGenerator(BackendProcessor* bp_):
			CommonData(bp_->getDatabaseRootDirectory())
		{
			data->createRootWindow(bp_);
		}

		Identifier getId() const override { return "MenuReferenceResolver"; }
		MarkdownParser::ResolveType getPriority() const override { return MarkdownParser::ResolveType::Autogenerated; }
		LinkResolver* clone(MarkdownParser*) const override { return new MenuGenerator(data->bp); }
		String getContent(const MarkdownLink& url) override;
		File getFileToEdit(const MarkdownLink& url) override;

		BackendRootWindow* getRootWindow() { return data->r; };
		
	};

	class SettingsGenerator : public MarkdownParser::LinkResolver,
							  public CommonData
	{
	public:

		SettingsGenerator(BackendProcessor& bp_) :
			CommonData(bp_.getDatabaseRootDirectory()),
			bp(bp_)
		{}

		Identifier getId() const override { return "SettingsResolver"; }
		MarkdownParser::ResolveType getPriority() const override { return MarkdownParser::ResolveType::Autogenerated; }
		LinkResolver* clone(MarkdownParser*) const override { return new SettingsGenerator(bp); }
		String getContent(const MarkdownLink& url) override;
		
		void addDescriptionForIdentifiers(String& s, const Array<Identifier>& id, const String& name);

		BackendProcessor& bp;
	};
};

}
